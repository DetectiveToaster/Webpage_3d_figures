diff --git a/README.md b/README.md
index b4281e3534e034ecf3ee8b0d13ad62e55550d35b..d8eb1eae75098df36478bc7ee1b3f652ca6dfe23 100644
GIT binary patch
literal 354
zcmZ9IL2rXF42AFc6_z-6J?u7Zl~BupuA0z5nsy=vT!@xAQ4&h|_X|~f7&lw~{GR<1
z_@c&QPxW(GpH)9P@<JpD6gU^CA?HB7!=MZcQBr^~5S)$HW>VY(@kKeqzr+D9=oB`Z
zJOmR5OZiZ-I4_8YX&?qSGB3-ER9fUOLP#k^k$xBHsotOR?4zpl!`tg@Mh70bYs?i|
ztrip2?N(%&?LV_>MSE%;h22e9RMDrw_J_Cwx?1DoiE{h6X&Xrlw28e%y)mvMCn382
eW6*{e%?gTts(U^JlM2J_rF(M663WB-llTKdIeU2k

literal 42
scmezWPnki1A)FzVA&H@YA(0^+$ckq$W=H{&X$+Y_eknr{P^_2%0N&^cMgRZ+

diff --git a/app/auth.py b/app/auth.py
index 961f6a0688f78a6231d5b9a8253c0fde1b4f0c3c..6099d99fcb98a0c272737b86f8f676ce07f1e5ca 100644
--- a/app/auth.py
+++ b/app/auth.py
@@ -1,76 +1,90 @@
 # app/auth.py
 
 from datetime import datetime, timedelta
 from typing import Optional
 from jose import JWTError, jwt
 from passlib.context import CryptContext
 from fastapi import Depends, HTTPException, status
 from fastapi.security import OAuth2PasswordBearer
 from sqlalchemy.orm import Session
 from . import schemas, models, crud
 from .database import get_db
 
 # Secret key to encode the JWT tokens
 SECRET_KEY = "your_secret_key_here"  # Change this to a more secure key
 ALGORITHM = "HS256"
 ACCESS_TOKEN_EXPIRE_MINUTES = 30
 
 pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
 
 oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
+oauth2_scheme_optional = OAuth2PasswordBearer(tokenUrl="token", auto_error=False)
 
 # Function to hash a password
 def hash_password(password: str):
     return pwd_context.hash(password)
 
 # Function to verify a password
 def verify_password(plain_password: str, hashed_password: str):
     return pwd_context.verify(plain_password, hashed_password)
 
 # Function to create a JWT token
 def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
     to_encode = data.copy()
     if expires_delta:
         expire = datetime.utcnow() + expires_delta
     else:
         expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
     to_encode.update({"exp": expire})
     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
     return encoded_jwt
 
 # Function to authenticate a user
 def authenticate_user(db: Session, email: str, password: str):
     user = crud.get_user_by_email(db, email=email)
     if not user:
         return False
     if not verify_password(password, user.password):
         return False
     return user
 
 # Function to get the current user from the token
 def get_current_user(db: Session = Depends(get_db), token: str = Depends(oauth2_scheme)):
     credentials_exception = HTTPException(
         status_code=status.HTTP_401_UNAUTHORIZED,
         detail="Could not validate credentials",
         headers={"WWW-Authenticate": "Bearer"},
     )
     try:
         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
         email: str = payload.get("sub")
         if email is None:
             raise credentials_exception
     except JWTError:
         raise credentials_exception
     user = crud.get_user_by_email(db, email=email)
     if user is None:
         raise credentials_exception
     return user
 
+# Variant that returns None instead of raising if token missing or invalid
+def get_current_user_optional(db: Session = Depends(get_db), token: str = Depends(oauth2_scheme_optional)):
+    if not token:
+        return None
+    try:
+        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
+        email: str = payload.get("sub")
+        if email is None:
+            return None
+    except JWTError:
+        return None
+    return crud.get_user_by_email(db, email=email)
+
 # Function to get the current active user
 def get_current_active_user(current_user: models.User = Depends(get_current_user)):
     return current_user
 
 def admin_required(current_user: models.User = Depends(get_current_active_user)):
     if not current_user.is_admin:
         raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Admins only")
     return current_user    
\ No newline at end of file
diff --git a/app/main.py b/app/main.py
index 6d5363978db3a0e70450110d04b4e238f56cab3c..e7ab8d6f8ffb1404e05e57a482d2f2107559da8c 100644
--- a/app/main.py
+++ b/app/main.py
@@ -1,43 +1,52 @@
 # app/main.py
 
 from fastapi import FastAPI, Depends, HTTPException, status, File, Form, UploadFile
 from sqlalchemy.orm import Session
 from datetime import datetime, timedelta
+import os
+from paypalcheckoutsdk.core import PayPalHttpClient, SandboxEnvironment
+from paypalcheckoutsdk.orders import OrdersCreateRequest, OrdersCaptureRequest
 from fastapi.security import OAuth2PasswordRequestForm
 from fastapi.responses import Response
 from fastapi.middleware.cors import CORSMiddleware
-from typing import List
+from typing import List, Optional
 from . import crud, models, schemas, auth
 from .database import SessionLocal, engine
-from .auth import authenticate_user, create_access_token, get_current_active_user, admin_required
+from .auth import authenticate_user, create_access_token, get_current_active_user, admin_required, get_current_user_optional
 
 # Initialize the database
 models.Base.metadata.create_all(bind=engine)
 
 app = FastAPI()
 
+# PayPal SDK configuration
+PAYPAL_CLIENT_ID = os.getenv("PAYPAL_CLIENT_ID")
+PAYPAL_CLIENT_SECRET = os.getenv("PAYPAL_CLIENT_SECRET")
+paypal_environment = SandboxEnvironment(client_id=PAYPAL_CLIENT_ID, client_secret=PAYPAL_CLIENT_SECRET)
+paypal_client = PayPalHttpClient(paypal_environment)
+
 app.add_middleware(
     CORSMiddleware,
     allow_origins=["http://localhost:3000"],  # or ["*"] for all origins during dev
     allow_credentials=True,
     allow_methods=["*"],
     allow_headers=["*"],
 )
 
 # Dependency to get DB session
 def get_db_session():
     db = SessionLocal()
     try:
         yield db
     finally:
         db.close()
 
 def create_admin_user():
     db = SessionLocal()
     admin_email = "admin@example.com"
     admin_password = "your_secure_password"
 
     existing_user = db.query(models.User).filter(models.User.email == admin_email).first()
     if not existing_user:
         hashed_password = auth.hash_password(admin_password)
         admin_user = models.User(
@@ -184,42 +193,96 @@ def get_media_file(media_id: int, db: Session = Depends(get_db_session)):
 @app.post("/categories/", response_model=schemas.Category)
 def create_category(category: schemas.CategoryBase, db: Session = Depends(get_db_session), current_user: models.User = Depends(admin_required)):
     return crud.create_category(db=db, category=category)
 
 # Public endpoint to get a list of categories
 @app.get("/categories/", response_model=List[schemas.Category])
 def read_categories(skip: int = 0, limit: int = 10, db: Session = Depends(get_db_session)):
     categories = crud.get_categories(db, skip=skip, limit=limit)
     return categories
 
 # Secure endpoint to create a new order
 @app.post("/orders/", response_model=schemas.Order)
 def create_order(order: schemas.OrderBase, db: Session = Depends(get_db_session), current_user: models.User = Depends(get_current_active_user)):
     return crud.create_order(db=db, order=order)
 
 # Public endpoint to get a list of orders (usually this would be secure, but depends on your needs)
 @app.get("/orders/", response_model=List[schemas.Order])
 def read_orders(skip: int = 0, limit: int = 10, db: Session = Depends(get_db_session)):
     orders = crud.get_orders(db, skip=skip, limit=limit)
     return orders
 
 @app.post("/guest_orders/", response_model=schemas.Order)
 def create_guest_order(order: schemas.GuestOrderBase, db: Session = Depends(get_db_session)):
     return crud.create_guest_order(db=db, order=order)
 
+# Create a PayPal order and return its ID
+@app.post("/payments/create-paypal-order")
+def create_paypal_order(
+    order_id: int,
+    db: Session = Depends(get_db_session),
+    current_user: Optional[models.User] = Depends(get_current_user_optional),
+):
+    order = db.query(models.Order).filter(models.Order.id == order_id).first()
+    if not order:
+        raise HTTPException(status_code=404, detail="Order not found")
+    if order.user_id and (not current_user or current_user.id != order.user_id):
+        raise HTTPException(status_code=403, detail="Not authorized to access this order")
+
+    request = OrdersCreateRequest()
+    request.prefer("return=representation")
+    request.request_body(
+        {
+            "intent": "CAPTURE",
+            "purchase_units": [
+                {
+                    "amount": {
+                        "currency_code": "USD",
+                        "value": str(order.total_cost),
+                    }
+                }
+            ],
+        }
+    )
+    response = paypal_client.execute(request)
+    return {"orderID": response.result.id}
+
+
+# Capture a PayPal order and update our database
+@app.post("/payments/capture-paypal-order")
+def capture_paypal_order(
+    order_id: int,
+    paypal_order_id: str,
+    db: Session = Depends(get_db_session),
+    current_user: Optional[models.User] = Depends(get_current_user_optional),
+):
+    order = db.query(models.Order).filter(models.Order.id == order_id).first()
+    if not order:
+        raise HTTPException(status_code=404, detail="Order not found")
+    if order.user_id and (not current_user or current_user.id != order.user_id):
+        raise HTTPException(status_code=403, detail="Not authorized to access this order")
+
+    request = OrdersCaptureRequest(paypal_order_id)
+    response = paypal_client.execute(request)
+    if response.result.status == "COMPLETED":
+        order.status = "paid"
+        db.commit()
+        db.refresh(order)
+    return {"status": response.result.status}
+
 # Secure endpoint to add an item to the cart
 @app.post("/cart/", response_model=schemas.Cart)
 def add_to_cart(cart: schemas.CartBase, db: Session = Depends(get_db_session), current_user: models.User = Depends(get_current_active_user)):
     return crud.add_to_cart(db=db, cart=cart)
 
 # Secure endpoint to view the cart of the current user
 @app.get("/cart/", response_model=List[schemas.Cart])
 def read_cart(db: Session = Depends(get_db_session), current_user: models.User = Depends(get_current_active_user)):
     return crud.get_cart_items(db=db, user_id=current_user.id)
 
 @app.put("/cart/{cart_id}", response_model=schemas.Cart)
 def update_cart_item(cart_id: int, quantity: int, db: Session = Depends(get_db_session), current_user: models.User = Depends(get_current_active_user)):
     return crud.update_cart_item(db, cart_id, quantity)
 
 @app.delete("/cart/{cart_id}", response_model=schemas.Cart)
 def delete_cart_item(cart_id: int, db: Session = Depends(get_db_session), current_user: models.User = Depends(get_current_active_user)):
     return crud.delete_cart_item(db, cart_id)
diff --git a/requirements.txt b/requirements.txt
index 4a9410af0f5a8d84909db74ce0a2f76b01595ee0..ceb5cee590a8632257cb0c1c2d02a36ebb477410 100644
--- a/requirements.txt
+++ b/requirements.txt
@@ -1,8 +1,9 @@
 fastapi
 sqlalchemy
 psycopg2-binary
 uvicorn
 passlib
 bcrypt
 python-jose
-python-multipart
\ No newline at end of file
+python-multipart
+paypalcheckoutsdk
\ No newline at end of file
